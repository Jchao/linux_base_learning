# Linux Shell 正则表达式
正则表达式(Regular Expression)，通常被用来检索、替换那些符合某个模式(规则)的文本。正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。

在实际Linux 使用过程中，尤其是使用 Linux 三剑客：grep，awk，sed时，正则表达式必不可少，其主要分为基本正则表达式(BREs)，扩展正则表达式(EREs)与 Perl 的正则表达式(PREs)。一般来讲，在够用的前提下，BREs使用的最多。
## 正则表达式入门
### Linux Shell 通配符
首先了解下 Linux 中的通配符，通配符通常用来匹配文件名操作，如：
```
[cc@redflag ~]$ ls /dev/sda?
/dev/sda1	/dev/sda2
[cc@redflag ~]$ ls /dev/sda*
/dev/sda	/dev/sda1	/dev/sda2
```
Shell 常用通配符及含义
| 通配符 | 含义 | 实例 |
| - | - | - |
| ? | 匹配任意一个字符 | a?b，匹配所有 a、b 之间有且仅有一个字符文件名 |
| * | 匹配0或多个字符 | sda*，匹配所有以 sda 开头的文件 |
| [list] | 匹配 list 中的任意单个字符 | a[xyz]b，a 与 b 之间有且仅有一个字符，必须是 x,y 或者 z |
| [^list] 或 [!list] | 匹配单个字符，非 list 中包含即可 | a[xyz]b，a 与 b 之间有且仅有一个字符，且不能是 x,y 或者 z |
| [C1-C2] | 以ASCII码表为准，匹配C1至 C2范围内任意一个字符 | a[0-9]b，仅匹配 a 与 b 之间为单个数字的文件 |
| [^C1-C2] 或 [!C1-C2] | 非 C1至 C2区间范围的任意一个字符 | a[!0-9]b，与上例相反 |
| {str1,str2,str3,,,} | 匹配其内包含的任意一字符串 | a{12,bc,yz}b，可匹配 a12b, abcb, ayzb |
由此表，结合小示例，通配符这点东西还是很简单的，可自己在系统中实践下即可。需要说明的是：通配符看起来有点象正则表达式语句，但是它与正则表达式不同的，不能相互混淆。把通配符理解为shell 特殊代号字符就可。而且涉及的只有，*,? [] ,{} 这几种。

### 语法
正则表达式是由普通字符（例如大小写字母、数字）以及特殊字符（称为"元字符"）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。
普通字符包括没有被指定为元字符(已转义)的所有可打印和不可打印字符，如数字、大小写字母所有的标点符号及部分其它符号。
非打印字符包括空格，换行，退格等等，其转义列表如下：
| 字符 | 含义 |
| - | - |
| “\ ” | 匹配一个空格 |
| \n | 匹配一个换行符 |
| \r | 匹配一个回车符 |
| \t | 匹配一个制表符 |
| \v | 匹配一个垂直制表符 |
| \f | 匹配一个换页符 |
| \s | 匹配任意空白字符，等价于[\n\r\f\t\v\ ]* |
| \S | 匹配任意非空白字符，与“\s”取反 |
#### 限定符
| 元字符 | 含义 |
| - | - |
| . | 匹配除换行符外任意单个字符 |
| * | 匹配前面子表达式0次或多次，不可单独使用 |
| \\{N\\} | 精确匹配到 N 次|
| \\{N,\\} | 匹配前面子表达式 N 次以上 |
| \\{N,M\\} | 匹配至少 N 次，至多 M 次 |
| [ ] | 匹配连续的范围或某字符串中的单个字符(与通配符用法同) |
| [^ ] | 与取反匹配(与通配符用法同) |
| \\w | 所有单词字符，数字，字母及下划线 |
| \\W | 与\\w 取反 |
| **扩展集** | **扩展正则表达式中的用法** |
| ? | 匹配前面子表达式0次或1次 |
| + | 匹配前面子表达式1次或多次 |
| {N} | 精确匹配到 N 次 |
| {N,} | 匹配 N 次以上 |
| {N,M} | 匹配至少 N 次，至多 M 次 |
这里再次强调，正则表达式与通配符并非一回事，其有部分相同点，但更要留意不一样的地方。
一个小例子，提取个人信息中11位手机号码与邮箱信息：
```
[cc@redflag ~]$ cat test
Jerry
94/04/11
Male

Beijing, China
www.redflag-linux.com

13201234567
jerry@redflag-linux.com
[cc@redflag ~]$ grep -E "1[0-9]{10}" test		#使用扩展模式，加 -E 参数
13201234567
[cc@redflag ~]$ grep "@.*\.com" test
jerry@redflag-linux.com
```
#### 定位符
定位符用来描述字符串或单词的边界，一般用来匹配行首、行尾或界定于单词中的位置等：
| 定位符 |含义 |
| - | - |
| ^ | 匹配输入字符串起始位置，或行首 |
| $ | 匹配输入字符串结尾位置，或行尾 |
| \< 与 \> | 词首定界符与词尾定界符 |
| \b | 匹配一个字边界，即词首\尾 |
| \B | 非字边界匹配 |
**注意：**定位符不可与限定符一起（连续）使用，因为边界(位置)有且仅有确定的一个。
在下面的测试文件中，第二行为空行，第三、四行则以 TAB 键开头：
```
[cc@redflag ~]$ cat man
This man is my friend.

His name is Jack Oldman.

	He lost the Instruction manual, ask me for help.
Somemanual work is needed here.
[cc@redflag ~]$ grep -n ^$ man
2:
[cc@redflag ~]$
```
使用 grep 命令时加上了-n 参数，故而这里显示 ，只有第二行为空行，空白行不等于空行。还可以在此测试下单词定界符的使用：

```
[cc@redflag ~]$ grep -n '\bman\b' man		#仅匹配包含单词 man 的行
1:This man is my friend.
[cc@redflag ~]$ grep -n 'man\B' man			#匹配包含 man 且不以其结尾的行
5:	He lost the Instruction manual, ask me for help.
6:Somemanual work is needed here.
```
#### 运算优先级
正则表达式从左到右进行计算，并遵循优先级顺序，下表由高到低列出：
| 运算符 | 描述 |
| - | - |
| \\ | 转义符 |
| (), [] | 圆括号与方括号 |
| +, *, {N},,, | 各种限定符 |
| ^, $, 任意字符 | 定位点和序列 |


























